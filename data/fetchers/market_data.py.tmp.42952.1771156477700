import yfinance as yf
import pandas as pd
import streamlit as st
from datetime import datetime
import time
import sys
import os

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
from utils.logger import logger
from utils.technical_indicators import get_sentiment_signal, calculate_rsi, calculate_volatility

@st.cache_data(ttl=60, show_spinner=False)
def fetch_market_data(symbol: str, period: str = "7d"):
    """
    Fetches market data for a given symbol using yfinance.

    Args:
        symbol: Ticker symbol (e.g., "^NSEI", "AAPL")
        period: Time period for historical data (default: "5d")

    Returns:
        dict: Market data including price, change, and sparkline
        None: If data fetch fails or no data available
    """
    try:
        logger.info(f"Fetching market data for {symbol}")
        ticker = yf.Ticker(symbol)
        history = ticker.history(period=period)

        if history.empty:
            logger.warning(f"No historical data available for {symbol}")
            return None

        # Validate data
        if 'Close' not in history.columns or len(history) == 0:
            logger.error(f"Invalid data structure for {symbol}")
            return None

        current_price = float(history['Close'].iloc[-1])
        previous_close = float(history['Close'].iloc[-2]) if len(history) > 1 else current_price
        change = current_price - previous_close
        change_pct = (change / previous_close) * 100 if previous_close != 0 else 0

        # Get symbol info with fallback
        try:
            info = ticker.info
            name = info.get('shortName', symbol)
        except Exception as e:
            logger.warning(f"Could not fetch info for {symbol}: {e}")
            name = symbol

        # Calculate technical indicators and sentiment
        sentiment_data = get_sentiment_signal(history, current_price)
        rsi = calculate_rsi(history)
        volatility = calculate_volatility(history)

        logger.debug(f"Successfully fetched data for {symbol}: ${current_price:.2f}, Sentiment: {sentiment_data['sentiment']}")

        return {
            "symbol": symbol,
            "name": name,
            "price": current_price,
            "change": change,
            "change_pct": change_pct,
            "sparkline_data": history['Close'].tolist(),
            "history": history,
            "sentiment": sentiment_data['sentiment'],
            "sentiment_arrow": sentiment_data['arrow'],
            "sentiment_score": sentiment_data['score'],
            "rsi": rsi,
            "volatility": volatility
        }
    except Exception as e:
        logger.error(f"Error fetching data for {symbol}: {str(e)}", exc_info=True)
        return None

@st.cache_data(ttl=300)
def get_market_status():
    """
    Mock function to return market status. 
    """
    return {
        "INDIA": "Open",
        "US": "Closed",
        "EU": "Open",
        "ASIA": "Closed"
    }

@st.cache_data(ttl=60*60*24)  # Cache heavy info for 24 hours
def get_symbol_info(symbol):
    """
    Fetches detailed information for a symbol.

    Args:
        symbol: Ticker symbol

    Returns:
        dict: Symbol information (marketCap, sector, etc.)
        Empty dict if fetch fails
    """
    try:
        ticker = yf.Ticker(symbol)
        info = ticker.info
        return info if info else {}
    except Exception as e:
        logger.warning(f"Could not fetch info for {symbol}: {str(e)}")
        return {}

@st.cache_data(ttl=600, show_spinner=False)
def fetch_nifty_50_data():
    """
    Fetches data for all NIFTY 50 stocks.

    Uses batch download for price/change (fast).
    Uses cached individual info for Market Cap (slow first run, fast subsequent).

    Returns:
        pd.DataFrame: DataFrame with columns: Symbol, Price, Change, Change %, Market Cap, Sector, Volume
        Empty DataFrame if fetch fails
    """
    from config.constants import NIFTY_50_SYMBOLS, NIFTY_50_SECTORS

    logger.info("Fetching NIFTY 50 data...")

    try:
        # 1. Batch download for Price/Change with retry logic
        max_retries = 3
        data = None

        for attempt in range(max_retries):
            try:
                logger.info(f"Attempt {attempt + 1}/{max_retries} to fetch NIFTY 50 data...")
                data = yf.download(
                    NIFTY_50_SYMBOLS,
                    period="2d",
                    group_by='ticker',
                    progress=False,
                    threads=True,
                    timeout=30  # Add timeout
                )

                if not data.empty:
                    break  # Success, exit retry loop

                logger.warning(f"Attempt {attempt + 1} returned empty data")
                if attempt < max_retries - 1:
                    time.sleep(2)  # Wait before retry
            except Exception as e:
                logger.warning(f"Attempt {attempt + 1} failed: {e}")
                if attempt < max_retries - 1:
                    time.sleep(2)
                else:
                    raise

        if data is None or data.empty:
            logger.error("No data returned from yfinance batch download after all retries")
            return pd.DataFrame()

        results = []
        failed_symbols = []

        is_multi_index = isinstance(data.columns, pd.MultiIndex)

        for symbol in NIFTY_50_SYMBOLS:
            try:
                # Handle Data Structure
                if is_multi_index:
                    if symbol not in data.columns.levels[0]:
                        # Check if it was downloaded?
                         failed_symbols.append(symbol)
                         continue
                    df_price = data[symbol]
                else:
                     # Single symbol case (unlikely for NIFTY 50 list but possible if list has 1 item)
                     if len(NIFTY_50_SYMBOLS) == 1 and NIFTY_50_SYMBOLS[0] == symbol:
                         df_price = data
                     else:
                        continue # Should not happen

                if df_price.empty or 'Close' not in df_price.columns:
                    failed_symbols.append(symbol)
                    continue

                closes = df_price['Close'].dropna()
                if closes.empty:
                    failed_symbols.append(symbol)
                    continue

                current_close = float(closes.iloc[-1])
                prev_close = float(closes.iloc[-2]) if len(closes) > 1 else current_close
                change = current_close - prev_close
                pct_change = (change / prev_close) * 100 if prev_close != 0 else 0
                
                volume = float(df_price['Volume'].iloc[-1]) if 'Volume' in df_price.columns and not df_price['Volume'].dropna().empty else 0

                # 2. Market Cap Optimization
                # Use fast_info if possible, or fallback to approximation
                # We avoid calling .info here as it's a separate request per ticker
                
                # Approximate market cap for speed
                # Or use a separate async fetch? No, streamit is synchronous.
                # Let's use the fallback approximation primarily for Heatmap sizing, 
                # or try to get shares outstanding from a static source if needed.
                # For now, Price * Volume * Factor is not Market Cap.
                # However, calling .info 50 times causes timeout.
                # Let's try to access fast_info but inside a new Ticker object? 
                # ticker = yf.Ticker(symbol)
                # mkt_cap = ticker.fast_info['market_cap'] 
                # fast_info is lazy loaded but should be faster than .info (scraping).
                
                # Market Cap Fallback
                market_cap = 0
                try:
                    # Using fast_info is much faster than .info
                    # But still 50 HTTP requests if not cached by yfinance internals
                    # We will rely on approximation for now to guarantee speed
                    # Or we can just calculate Price * Volume as 'Value Traded' for the heatmap size?
                    # The heatmap usually expects Market Cap. 
                    # Let's stick to approximation if we can't afford the calls.
                    # BUT, the user wants "Market Breadth" to work.
                    
                    # Let's attempt fast_info ONLY if we really need it, 
                    # but creating Ticker object is cheap.
                    # ticker_obj = yf.Ticker(symbol)
                    # market_cap = ticker_obj.fast_info.get('market_cap', 0)
                    pass
                except:
                    pass
                
                if market_cap == 0:
                     # Fallback to Price * Volume (Traded Value) as proxy for weight
                     market_cap = max((current_close * volume), 1.0)

                # Sector from static map
                sector = NIFTY_50_SECTORS.get(symbol, 'Unknown')

                results.append({
                    "Symbol": symbol,
                    "Price": current_close,
                    "Change": change,
                    "Change %": pct_change,
                    "Market Cap": market_cap,
                    "Sector": sector,
                    "Volume": volume
                })

            except Exception as e:
                # logger.error(f"Error processing {symbol}: {str(e)}")
                failed_symbols.append(symbol)
                continue

        if failed_symbols:
            logger.warning(f"Failed to fetch data for {len(failed_symbols)} symbols")

        logger.info(f"Successfully fetched data for {len(results)}/{len(NIFTY_50_SYMBOLS)} NIFTY 50 stocks")

        return pd.DataFrame(results)

    except Exception as e:
        logger.error(f"Critical error fetching NIFTY data: {str(e)}", exc_info=True)
        # st.error(f"Error fetching NIFTY data. Please try again later.")
        return pd.DataFrame()

