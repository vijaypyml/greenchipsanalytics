import yfinance as yf
import pandas as pd
import streamlit as st
from datetime import datetime
import time
import sys
import os

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
from utils.logger import logger

@st.cache_data(ttl=60)
def fetch_market_data(symbol: str, period: str = "5d"):
    """
    Fetches market data for a given symbol using yfinance.
    Returns a dictionary with current price, change, and history.
    """
    try:
        ticker = yf.Ticker(symbol)
        history = ticker.history(period=period)
        
        if history.empty:
            return None

        current_price = history['Close'].iloc[-1]
        previous_close = history['Close'].iloc[-2] if len(history) > 1 else current_price
        change = current_price - previous_close
        change_pct = (change / previous_close) * 100

        info = ticker.info
        name = info.get('shortName', symbol)

        return {
            "symbol": symbol,
            "name": name,
            "price": current_price,
            "change": change,
            "change_pct": change_pct,
            "sparkline_data": history['Close'].tolist(),
            "history": history
        }
    except Exception as e:
        print(f"Error fetching data for {symbol}: {e}")
        return None

@st.cache_data(ttl=300)
def get_market_status():
    """
    Mock function to return market status. 
    """
    return {
        "INDIA": "Open",
        "US": "Closed",
        "EU": "Open",
        "ASIA": "Closed"
    }

@st.cache_data(ttl=60*60*24) # Cache heavy info for 24 hours
def get_symbol_info(symbol):
    try:
        ticker = yf.Ticker(symbol)
        return ticker.info
    except:
        return {}

@st.cache_data(ttl=600)
def fetch_nifty_50_data():
    """
    Fetches data for all NIFTY 50 stocks.
    Uses batch download for price/change (fast).
    Uses cached individual info for Market Cap (slow first run, fast subsequent).
    """
    from config.constants import NIFTY_50_SYMBOLS
    
    try:
        # 1. Batch download for Price/Change
        data = yf.download(NIFTY_50_SYMBOLS, period="2d", group_by='ticker', progress=False)
        
        results = []
        
        for symbol in NIFTY_50_SYMBOLS:
            try:
                # Handle Data Structure: data[symbol] might differ based on yf version/result
                if symbol in data:
                    df_price = data[symbol]
                else:
                    continue

                if df_price.empty or len(df_price) < 1:
                    continue
                    
                current_close = df_price['Close'].iloc[-1]
                prev_close = df_price['Close'].iloc[-2] if len(df_price) > 1 else current_close
                change = current_close - prev_close
                pct_change = (change / prev_close) * 100
                
                # 2. Market Cap (Via separate cached function)
                info = get_symbol_info(symbol)
                market_cap = info.get('marketCap', 0)
                sector = info.get('sector', 'Unknown')
                
                # Fallback: If Market Cap is 0/None, use Price * Volume (Turnover) as proxy
                # This ensures we don't get "Weights sum to zero" error in Treemap
                if not market_cap or market_cap == 0:
                     vol = df_price['Volume'].iloc[-1] if 'Volume' in df_price.columns else 0
                     # If volume is also 0, use a default small strictly positive epsilon
                     market_cap = (current_close * vol) if vol > 0 else 1.0

                results.append({
                    "Symbol": symbol,
                    "Price": current_close,
                    "Change": change,
                    "Change %": pct_change,
                    "Market Cap": market_cap,
                    "Sector": sector,
                    "Volume": df_price['Volume'].iloc[-1] if 'Volume' in df_price.columns else 0
                })
            except Exception as e:
                continue

        return pd.DataFrame(results)

    except Exception as e:
        st.error(f"Error fetching NIFTY data: {e}")
        return pd.DataFrame()
